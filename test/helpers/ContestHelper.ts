import { ethers } from "hardhat";
import { time } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { 
    ContestFactory, 
    ContestEscrow, 
    NetworkFeeManager 
} from "../../typechain-types";
import { TEST_CONSTANTS, CONTEST_TEMPLATES } from "../fixtures";
import { prepareERC20Token } from "./TokenHelper";

export interface CreateContestOptions {
    token?: string;
    totalPrize?: bigint;
    template?: number;
    startDelay?: number;
    duration?: number;
    startTime?: bigint;    
    endTime?: bigint;      
    jury?: string[];
    metadata?: {
        title?: string;
        description?: string;
    };

    hasNonMonetaryPrizes?: boolean;
    uniqueId?: number;
    customDistribution?: Array<{
        place: number;
        percentage: number;
        description: string;
    }>;
}

export async function createTestContest(
    contestFactory: ContestFactory,
    feeManager: NetworkFeeManager,
    creator: any,
    options: CreateContestOptions = {}
): Promise<{
    contestId: bigint;
    escrow: ContestEscrow;
    escrowAddress: string;
    transaction: any;
    receipt: NonNullable<Awaited<ReturnType<typeof ethers.ContractTransactionResponse.prototype.wait>>>;
}> {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è lastId –¥–æ—Å—Ç—É–ø–Ω–∞
    let hasLastIdFunction;
    let initialLastId = BigInt(0);
    try {
        initialLastId = await contestFactory.lastId();
        console.log(`–ù–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ lastId –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º –∫–æ–Ω–∫—É—Ä—Å–∞: ${initialLastId}`);
        hasLastIdFunction = true;
    } catch (error) {
        console.warn(`–§—É–Ω–∫—Ü–∏—è lastId –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞: ${error}`);
        hasLastIdFunction = false;
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å —Ç–æ–∫–µ–Ω–∞, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ ETH
    if (options.token && options.token !== ethers.ZeroAddress) {
        try {
            const validator = await ethers.getContractAt("TokenValidator", await contestFactory.tokenValidator());
            const isValidToken = await validator.isValidToken(options.token);
            const isStablecoin = await validator.isStablecoin(options.token);
            console.log(`üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Ç–æ–∫–µ–Ω–∞: isValidToken=${isValidToken}, isStablecoin=${isStablecoin}`);

            // –ï—Å–ª–∏ —Ç–æ–∫–µ–Ω –Ω–µ –≤–∞–ª–∏–¥–µ–Ω, –ø–æ–ø—Ä–æ–±—É–µ–º –∏—Å–ø—Ä–∞–≤–∏—Ç—å
            if (!isValidToken) {
                console.log(`‚ö†Ô∏è –¢–æ–∫–µ–Ω –Ω–µ –ø—Ä–æ—à—ë–ª –≤–∞–ª–∏–¥–∞—Ü–∏—é, –ø—Ä–æ–±—É–µ–º –∏—Å–ø—Ä–∞–≤–∏—Ç—å...`);
                const [owner] = await ethers.getSigners();
                await validator.connect(owner).setTokenWhitelist(options.token, true, "Added for test");

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—â–µ —Ä–∞–∑ whitelist –ø–æ—Å–ª–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                const isValidNow = await validator.isValidToken(options.token);
                console.log(`üîÑ –ü–æ—Å–ª–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è whitelist: isValidToken=${isValidNow}`);
            }

            // –û—Ç–¥–µ–ª—å–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω
            if (!isStablecoin) {
                console.log(`‚ö†Ô∏è –¢–æ–∫–µ–Ω –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –∫–∞–∫ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω, –ø—Ä–æ–±—É–µ–º –∏—Å–ø—Ä–∞–≤–∏—Ç—å...`);
                const [owner] = await ethers.getSigners();

                // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–∫–µ–Ω–µ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
                const mockToken = await ethers.getContractAt("MockERC20", options.token);
                const tokenSymbol = await mockToken.symbol();
                console.log(`–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–∞ –¥–ª—è —Ç–æ–∫–µ–Ω–∞: ${tokenSymbol}`);

                // –ü—Ä—è–º–∞—è –≤—Å—Ç–∞–≤–∫–∞ –≤ –º–∞—Å—Å–∏–≤ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–æ–≤ (–µ—Å–ª–∏ –µ—Å—Ç—å –º–µ—Ç–æ–¥ updateStablecoins)
                try {
                    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–æ–≤
                    const stablecoins = await validator.stablecoins
                        ? await validator.stablecoins(0).then(() => {
                            let coins = [];
                            let i = 0;
                            return (async function getCoins() {
                                try {
                                    while (true) {
                                        coins.push(await validator.stablecoins(i));
                                        i++;
                                    }
                                } catch {
                                    return coins;
                                }
                            })();
                        })
                        : [];

                    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω –≤ –º–∞—Å—Å–∏–≤, –µ—Å–ª–∏ —Ç–∞–∫–æ–≥–æ –º–µ—Ç–æ–¥–∞ –µ—â–µ –Ω–µ—Ç
                    await validator.connect(owner).batchWhitelist(
                        [options.token],
                        [true],
                        `Stablecoin ${tokenSymbol} for tests`
                    );

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –º–µ—Ç–æ–¥ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–æ–≤
                    const code = await ethers.provider.getCode(await validator.getAddress());
                    console.log(`–ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –º–µ—Ç–æ–¥–∞ –¥–ª—è —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–æ–≤...`);

                    // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –ø–æ–¥—Ö–æ–¥—ã –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–∞
                    try {
                        // –ü—ã—Ç–∞–µ–º—Å—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–æ–∫–µ–Ω –∫–∞–∫ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω –Ω–∞–ø—Ä—è–º—É—é
                        await validator.connect(owner).setTokenIsStablecoin?.(options.token, true);
                        console.log(`‚úÖ –¢–æ–∫–µ–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∫–∞–∫ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω —á–µ—Ä–µ–∑ setTokenIsStablecoin`);
                    } catch (e) {
                        console.log(`–ù–µ —É–¥–∞–ª–æ—Å—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å setTokenIsStablecoin: ${e.message}`);

                        try {
                            // –ü—Ä–æ–±—É–µ–º –æ–±–Ω–æ–≤–∏—Ç—å TokenInfo –Ω–∞–ø—Ä—è–º—É—é
                            await validator.connect(owner).updateTokenInfo?.(options.token);
                            console.log(`‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–æ–∫–µ–Ω–µ —á–µ—Ä–µ–∑ updateTokenInfo`);
                        } catch (e2) {
                            console.log(`–ù–µ —É–¥–∞–ª–æ—Å—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å updateTokenInfo: ${e2.message}`);
                        }
                    }
                } catch (updateErr) {
                    console.log(`‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω—ã: ${updateErr}`);
                }

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—â–µ —Ä–∞–∑ –ø–æ—Å–ª–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                const isStablecoinNow = await validator.isStablecoin(options.token);
                console.log(`üîÑ –ü–æ—Å–ª–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–∞: isStablecoin=${isStablecoinNow}`);
            }
        } catch (error) {
            console.warn(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ —Ç–æ–∫–µ–Ω–∞: ${error}`);
        }
    }
    console.log("–ù–∞—á–∞–ª–æ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∫–æ–Ω–∫—É—Ä—Å–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏:", JSON.stringify(options, (_, value) => 
        typeof value === 'bigint' ? value.toString() : value
    ));
    const now = await time.latest();
    const uniqueId = options.uniqueId || Math.floor(Math.random() * 1000000);
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º startTime –∏ endTime –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, –µ—Å–ª–∏ –æ–Ω–∏ —É–∫–∞–∑–∞–Ω—ã
    const startTime = options.startTime ? options.startTime : 
        BigInt(now + (options.startDelay || TEST_CONSTANTS.DEFAULT_START_DELAY) + (uniqueId % 100));

    const endTime = options.endTime ? options.endTime :
        BigInt(now + (options.startDelay || TEST_CONSTANTS.DEFAULT_START_DELAY) + 
        (options.duration || TEST_CONSTANTS.DEFAULT_DURATION));

    const config = {
        token: options.token || ethers.ZeroAddress,
        totalPrize: options.totalPrize || TEST_CONSTANTS.MEDIUM_PRIZE,
        template: options.template !== undefined ? options.template : CONTEST_TEMPLATES.TOP_2,
        jury: options.jury || [],
        hasNonMonetaryPrizes: options.hasNonMonetaryPrizes || false,
        customDistribution: options.customDistribution || []
    };

    const contestParams = {
        token: config.token,
        totalPrize: config.totalPrize,
        template: config.template,
        customDistribution: config.customDistribution.length > 0 ? config.customDistribution : [],
        jury: config.jury,
        startTime: startTime,
        endTime: endTime,
        contestMetadata: JSON.stringify({
            title: options.metadata?.title || `Test Contest #${uniqueId}`,
            description: options.metadata?.description || `Test contest for automated testing (ID: ${uniqueId})`
        }),
        hasNonMonetaryPrizes: config.hasNonMonetaryPrizes
    };

    let createTx;
    
    if (config.token === ethers.ZeroAddress) {
        const platformFee = await feeManager.calculateFee(31337, config.totalPrize);
        const totalRequired = config.totalPrize + platformFee;
        
        console.log(`–°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω–∫—É—Ä—Å–∞ —Å ETH: –ø—Ä–∏–∑=${ethers.formatEther(config.totalPrize)}, –∫–æ–º–∏—Å—Å–∏—è=${ethers.formatEther(platformFee)}, –≤—Å–µ–≥–æ=${ethers.formatEther(totalRequired)}`);

        try {
            createTx = await contestFactory.connect(creator).createContest(contestParams, {
                value: totalRequired,
                gasLimit: 5000000  // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ª–∏–º–∏—Ç –≥–∞–∑–∞
            });
        } catch (error) {
            console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–æ–Ω–∫—É—Ä—Å–∞ —Å ETH: ${error}`);
            throw error;
        }
    } else {
        const token = await ethers.getContractAt("MockERC20", config.token);
        const platformFee = await feeManager.calculateFee(31337, config.totalPrize);
        const totalRequired = config.totalPrize + platformFee;

        const tokenValidator = await ethers.getContractAt("TokenValidator", 
            await contestFactory.tokenValidator()
        );
        
        // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–∫–µ–Ω –≤ –±–µ–ª—ã–π —Å–ø–∏—Å–æ–∫ –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º –∫–æ–Ω–∫—É—Ä—Å–∞
        try {
            const isWhitelisted = await tokenValidator.whitelistedTokens(config.token);
            if (!isWhitelisted) {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º owner, –∞ –Ω–µ creator –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ whitelist
                const [owner] = await ethers.getSigners();
                const addToWhitelistTx = await tokenValidator.connect(owner).setTokenWhitelist(
                    config.token,
                    true,
                    "Test whitelist for mock token"
                );
                await addToWhitelistTx.wait();
                console.log(`   ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω –≤ whitelist —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º owner`);
            } else {
                console.log(`   ‚ÑπÔ∏è –¢–æ–∫–µ–Ω —É–∂–µ –≤ whitelist`);
            }
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–∞ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            try {
                // –í TypeScript –Ω–µ –≤–∏–¥–∏—Ç –º–µ—Ç–æ–¥ isStablecoin, –Ω–æ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–µ
                // @ts-ignore: Property 'isStablecoin' does not exist on type 'TokenValidator'
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–µ—Ç–æ–¥ isStablecoin –∏–∑ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ ITokenValidator
                const isStablecoin = await tokenValidator.isStablecoin(config.token);
                if (!isStablecoin) {
                    const [owner] = await ethers.getSigners();

                    // –ü–æ–ª—É—á–∞–µ–º —Å–∏–º–≤–æ–ª —Ç–æ–∫–µ–Ω–∞ —á–µ—Ä–µ–∑ getContractAt –≤–º–µ—Å—Ç–æ IERC20Metadata
                    const mockToken = await ethers.getContractAt("MockERC20", config.token);
                    const tokenSymbol = await mockToken.symbol();

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–æ–∫–µ–Ω –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–º —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–æ–º –ø–æ –∏–º–µ–Ω–∏
                    const stablecoinSymbols = ['USDT', 'USDC', 'BUSD', 'DAI'];
                    const isStablecoinSymbol = stablecoinSymbols.includes(tokenSymbol) || 
                                             tokenSymbol.startsWith('USD');

                    if (isStablecoinSymbol) {
                        // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –º–µ—Ç–æ–¥—ã –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–∞
                        try {
                            // –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å —Ç–∏–ø –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤
                            // @ts-ignore: –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫—É, —Ç–∞–∫ –∫–∞–∫ –º–µ—Ç–æ–¥ –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–µ–Ω –≤ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
                            const isMock = await tokenValidator.isMockTokenValidator?.().catch(() => false);

                            if (isMock) {
                                // –ï—Å–ª–∏ —ç—Ç–æ –º–æ–∫, –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–µ—Ç–æ–¥ setupToken
                                const mockValidator = await ethers.getContractAt("MockTokenValidator", await tokenValidator.getAddress());
                                await mockValidator.connect(owner).setupToken(
                                    config.token,
                                    await mockToken.name(),
                                    tokenSymbol,
                                    await mockToken.decimals(),
                                    ethers.parseUnits("1", 8), // $1 —Å 8 –¥–µ—Å—è—Ç–∏—á–Ω—ã–º–∏
                                    true, // isStable = true
                                    false  // isWrappedNative = false
                                );
                            } else {
                                // –î–ª—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–∞
                                await tokenValidator.connect(owner).setTokenIsStablecoin(config.token, true);
                            }
                            console.log(`   ‚úÖ –¢–æ–∫–µ–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∫–∞–∫ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω`);
                        } catch (error) {
                            console.log(`   ‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–∞: ${error}`);

                            // –î–æ–±–∞–≤–ª—è–µ–º –≤ –º–∞—Å—Å–∏–≤ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–æ–≤ –Ω–∞–ø—Ä—è–º—É—é, –µ—Å–ª–∏ —ç—Ç–æ –≤–æ–∑–º–æ–∂–Ω–æ
                            try {
                                const stablecoinsField = await tokenValidator.getStablecoins().catch(() => []);
                                if (Array.isArray(stablecoinsField)) {
                                    // @ts-ignore: –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫—É, —Ç–∞–∫ –∫–∞–∫ –º–µ—Ç–æ–¥ –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–µ–Ω –≤ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
                                    await tokenValidator.connect(owner).updateStablecoins?.([
                                        ...stablecoinsField, config.token
                                    ]);
                                    console.log(`   ‚úÖ –¢–æ–∫–µ–Ω –¥–æ–±–∞–≤–ª–µ–Ω –≤ –º–∞—Å—Å–∏–≤ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–æ–≤`);
                                }
                            } catch (updateError) {
                                console.log(`   ‚ö†Ô∏è –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–æ–≤: ${updateError}`);
                            }
                        }
                    } else {
                        console.log(`   ‚ÑπÔ∏è –¢–æ–∫–µ–Ω ${tokenSymbol} –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –∫–∞–∫ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω –ø–æ —Å–∏–º–≤–æ–ª—É`);
                    }
                } else {
                    console.log(`   ‚úÖ –¢–æ–∫–µ–Ω —É–∂–µ —è–≤–ª—è–µ—Ç—Å—è —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–æ–º`);
                }
            } catch (stablecoinError) {
                console.log(`   ‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ñ–ª–∞–≥ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–∞: ${stablecoinError}`);
            }
        } catch (error) {
            console.log(`   ‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å —Ç–æ–∫–µ–Ω –≤ whitelist: ${error}`);
        }

        await prepareERC20Token(
            token,
            tokenValidator,
            creator,
            totalRequired,
            await contestFactory.getAddress()
        );
        
        console.log(`–°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω–∫—É—Ä—Å–∞ —Å —Ç–æ–∫–µ–Ω–æ–º ${config.token}: –ø—Ä–∏–∑=${config.totalPrize}, –∫–æ–º–∏—Å—Å–∏—è=${platformFee}, –≤—Å–µ–≥–æ=${totalRequired}`);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å totalRequired –ø—Ä–∏ –≤—ã–∑–æ–≤–µ createContest
        // –ï—Å–ª–∏ —Ç–æ–∫–µ–Ω —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω, —Ç–æ –≤ —Å–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç–µ –ª–æ–≥–∏–∫–∞ –∫–æ–º–∏—Å—Å–∏–∏ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è
        const isStablecoin = await tokenValidator.isStablecoin(config.token);
        console.log(`–¢–æ–∫–µ–Ω ${await token.symbol()} —è–≤–ª—è–µ—Ç—Å—è —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–æ–º: ${isStablecoin}`);

        // –ü–æ–ª—É—á–∞–µ–º –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–∂–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–æ–∫–µ–Ω–∞
        const tokenDecimals = await token.decimals();
        const tokenName = await token.name();
        const tokenSymbol = await token.symbol();
        console.log(`–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–æ–∫–µ–Ω–∞: name=${tokenName}, symbol=${tokenSymbol}, decimals=${tokenDecimals}`);

        try {
            // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –æ—Ü–µ–Ω–∏—Ç—å –≥–∞–∑ –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–∏
            try {
                const gasEstimate = await contestFactory.connect(creator).createContest.estimateGas(contestParams);
                console.log(`–û—Ü–µ–Ω–∫–∞ –≥–∞–∑–∞ –¥–ª—è createContest: ${gasEstimate} (–¥–æ–±–∞–≤–∏–º 30% –∑–∞–ø–∞—Å–∞)`);                
                const gasLimit = Math.ceil(Number(gasEstimate) * 1.3); // –î–æ–±–∞–≤–ª—è–µ–º 30% –∑–∞–ø–∞—Å–∞

                createTx = await contestFactory.connect(creator).createContest(contestParams, {
                    gasLimit: gasLimit
                });
                console.log(`–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ —Å gasLimit: ${gasLimit}`);
            } catch (gasError) {
                console.warn(`–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ü–µ–Ω–∏—Ç—å –≥–∞–∑: ${gasError}, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ`);                

                // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ü–µ–Ω–∏—Ç—å –≥–∞–∑, –∏—Å–ø–æ–ª—å–∑—É–µ–º —É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π –ª–∏–º–∏—Ç
                const gasLimit = 30000000; // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ª–∏–º–∏—Ç –≥–∞–∑–∞ –µ—â–µ –±–æ–ª—å—à–µ
                console.log(`–ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π gasLimit: ${gasLimit}`);

                createTx = await contestFactory.connect(creator).createContest(contestParams, {
                    gasLimit: gasLimit
                });
            }
        } catch (error) {
            console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–æ–Ω–∫—É—Ä—Å–∞ —Å —Ç–æ–∫–µ–Ω–æ–º: ${error}`);


            // –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –æ—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
            const err = error as any; // –Ø–≤–Ω–æ–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –∫ any –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Å–≤–æ–π—Å—Ç–≤–∞–º

            if (err && typeof err === 'object') {
                if ('message' in err) {
                    console.error(`–°–æ–æ–±—â–µ–Ω–∏–µ –æ—à–∏–±–∫–∏: ${err.message}`);
                }

                if ('code' in err) {
                    console.error(`–ö–æ–¥ –æ—à–∏–±–∫–∏: ${err.code}`);
                }

                if ('transaction' in err) {
                    console.error(`–î–∞–Ω–Ω—ã–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: ${JSON.stringify(err.transaction)}`);
                }

                if ('receipt' in err) {
                    console.error(`–ß–µ–∫ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: ${JSON.stringify(err.receipt)}`);
                }
            }

            throw error;
        }
    }

    const receipt = await createTx.wait();
    if (!receipt) throw new Error("Transaction receipt is null");
    if (!receipt.logs) throw new Error("Transaction receipt logs are missing");

    console.log(`–ü–æ–ª—É—á–µ–Ω–æ ${receipt.logs.length} –ª–æ–≥–æ–≤ –∏–∑ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏`);

    let contestId: bigint | null = null;
    let escrowAddress: string | null = null;

    // –ë–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω—ã–π —Å–ø–æ—Å–æ–± –ø–æ–∏—Å–∫–∞ —Å–æ–±—ã—Ç–∏—è –ø–æ topicHash
    let eventTopicHash;
    try {
        const eventDef = contestFactory.interface.getEvent("ContestCreated");
        eventTopicHash = eventDef?.topicHash;
        console.log(`–ù–∞–π–¥–µ–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è ContestCreated —Å topicHash: ${eventTopicHash}`);
    } catch (error) {
        console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ topicHash –¥–ª—è ContestCreated: ${error}`);
    }

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã —Ö–µ—à–µ–π –¥–ª—è —Å–æ–±—ã—Ç–∏—è
    const possibleSignatures = [
        "ContestCreated(uint256,address,address,uint256,uint256)",
        "ContestCreated(uint256,address,address,address,uint256,uint256)",
        "ContestCreated(uint256,address,address)"
    ];

    const signatureHashes = [];
    for (const sig of possibleSignatures) {
        try {
            const hash = ethers.id(sig);
            signatureHashes.push(hash);
            console.log(`–•–µ—à –¥–ª—è —Å–∏–≥–Ω–∞—Ç—É—Ä—ã ${sig}: ${hash}`);
        } catch (err) {
            console.error(`–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ö–µ—à –¥–ª—è ${sig}: ${err}`);
        }
    }

    // –í—ã–≤–æ–¥–∏–º –ø–µ—Ä–≤—ã–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ topicHash –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    if (receipt.logs.length > 0) {
        console.log(`–ü–µ—Ä–≤—ã–µ —Ç–æ–ø–∏–∫–∏ –ª–æ–≥–æ–≤:`);
        for (let i = 0; i < Math.min(5, receipt.logs.length); i++) {
            if (receipt.logs[i].topics.length > 0) {
                console.log(`Log ${i}: ${receipt.logs[i].topics[0]}`);
            }
        }
    }

    let contestCreatedLog = null;

    // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ —á–µ—Ä–µ–∑ eventTopicHash
    if (eventTopicHash) {
        contestCreatedLog = receipt.logs.find(log => 
            log.topics.length > 0 && log.topics[0] === eventTopicHash
        );

        if (contestCreatedLog) {
            console.log(`–ù–∞–π–¥–µ–Ω –ª–æ–≥ —Å –æ—Å–Ω–æ–≤–Ω—ã–º —Ö–µ—à–µ–º —Å–æ–±—ã—Ç–∏—è: ${eventTopicHash}`);
        }
    }

    // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, –ø—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ö–µ—à–∏
    if (!contestCreatedLog) {
        for (const hash of signatureHashes) {
            const log = receipt.logs.find(log => 
                log.topics.length > 0 && log.topics[0] === hash
            );

            if (log) {
                contestCreatedLog = log;
                console.log(`–ù–∞–π–¥–µ–Ω –ª–æ–≥ —Å –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–º —Ö–µ—à–µ–º —Å–æ–±—ã—Ç–∏—è: ${hash}`);
                break;
            }
        }
    }

    if (contestCreatedLog) {
        try {
            const decodedEvent = contestFactory.interface.parseLog(contestCreatedLog);
            if (decodedEvent && decodedEvent.args) {
                    // –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –ø–æ –∏–º–µ–Ω–∞–º
                    contestId = decodedEvent.args.contestId;
                    escrowAddress = decodedEvent.args.escrow;

                    // –ï—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å, –ø—Ä–æ–±—É–µ–º –ø–æ –∏–Ω–¥–µ–∫—Å–∞–º
                    if (!contestId) {
                        contestId = decodedEvent.args[0];
                    }

                    if (!escrowAddress) {
                        // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è escrowAddress
                        for (let i = 1; i < 4; i++) {
                            if (ethers.isAddress(decodedEvent.args[i])) {
                                escrowAddress = decodedEvent.args[i];
                                break;
                            }
                        }
                    }

                    console.log(`–ù–∞–π–¥–µ–Ω–æ —Å–æ–±—ã—Ç–∏–µ ContestCreated! ID: ${contestId}, –≠—Å–∫—Ä–æ—É: ${escrowAddress}`);
                }
            } catch (error) {
                console.log(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–±–æ—Ä–µ —Å–æ–±—ã—Ç–∏—è: ${error}`);

                // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–æ–±—Ä–∞—Ç—å –≤—Ä—É—á–Ω—É—é
                try {
                    // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –ø–µ—Ä–≤—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä - contestId, –∞ –æ–¥–∏–Ω –∏–∑ —Å–ª–µ–¥—É—é—â–∏—Ö - escrowAddress
                    const data = contestCreatedLog.data;
                    const topics = contestCreatedLog.topics;

                    console.log(`–î–∞–Ω–Ω—ã–µ –ª–æ–≥–∞: data=${data}, topics=${topics.join(', ')}`);

                    // –ü—Ä–æ–±—É–µ–º –∏–∑–≤–ª–µ—á—å contestId –∏–∑ –ø–µ—Ä–≤–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –≤ data (—É–±–∏—Ä–∞–µ–º 0x –∏ –±–µ—Ä–µ–º –ø–µ—Ä–≤—ã–µ 64 —Å–∏–º–≤–æ–ª–∞)
                    if (data && data.length >= 66) {
                        const idHex = '0x' + data.substring(2, 66);
                        contestId = BigInt(idHex);
                        console.log(`–ò–∑–≤–ª–µ—á–µ–Ω contestId=${contestId} –∏–∑ data`);
                    }

                    // –ü—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –∞–¥—Ä–µ—Å –≤ data
                    if (data && data.length >= 130) {
                        const addrHex = '0x' + data.substring(26, 66); // 40 —Å–∏–º–≤–æ–ª–æ–≤ —Å –æ—Ç—Å—Ç—É–ø–æ–º
                        if (ethers.isAddress(addrHex)) {
                            escrowAddress = addrHex;
                            console.log(`–ò–∑–≤–ª–µ—á–µ–Ω escrowAddress=${escrowAddress} –∏–∑ data`);
                        }
                    }
                } catch (innerError) {
                    console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä—É—á–Ω–æ–º —Ä–∞–∑–±–æ—Ä–µ —Å–æ–±—ã—Ç–∏—è: ${innerError}`);
                }
        }
    } else {
        // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ —Å–æ–±—ã—Ç–∏–µ, –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –ª–æ–≥–∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ
        console.log(`–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö ${receipt.logs.length} –ª–æ–≥–æ–≤ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ ContestCreated...`);
        for (const log of receipt.logs) {
            try {
                const parsed = contestFactory.interface.parseLog({
                    topics: log.topics,
                    data: log.data
                });

                if (parsed && parsed.name === "ContestCreated" && parsed.args) {
                    contestId = parsed.args.contestId;
                    escrowAddress = parsed.args.escrow;
                    console.log(`–ù–∞–π–¥–µ–Ω–æ —Å–æ–±—ã—Ç–∏–µ ContestCreated! ID: ${contestId}, –≠—Å–∫—Ä–æ—É: ${escrowAddress}`);
                    break;
                }
            } catch (error) {
                // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
                continue;
            }
        }
    }

    // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ —Å–æ–±—ã—Ç–∏–µ, –ø–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –¥—Ä—É–≥–∏–º —Å–ø–æ—Å–æ–±–æ–º
    if (contestId === null || !escrowAddress) {
        console.log("–ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫–æ–Ω–∫—É—Ä—Å–µ...");

        // –ü–æ–ª—É—á–∞–µ–º lastId –∏–∑ ContestFactory, –∫–æ—Ç–æ—Ä—ã–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ä–∞–≤–µ–Ω —Ç–æ–ª—å–∫–æ —á—Ç–æ —Å–æ–∑–¥–∞–Ω–Ω–æ–º—É contestId
        try {
            contestId = await contestFactory.lastId();
            console.log(`–ü–æ–ª—É—á–µ–Ω contestId –∏–∑ lastId: ${contestId}`);

            // –ï—Å–ª–∏ contestId —Ä–∞–≤–µ–Ω 0, —ç—Ç–æ –º–æ–∂–µ—Ç –æ–∑–Ω–∞—á–∞—Ç—å, —á—Ç–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å –∏–ª–∏ –∫–æ–Ω—Ç—Ä–∞–∫—Ç –Ω–µ –æ–±–Ω–æ–≤–∏–ª —Å—á–µ—Ç—á–∏–∫
            if (contestId === BigInt(0)) {
                console.warn("Warning: lastId –≤–µ—Ä–Ω—É–ª 0, —á—Ç–æ –º–æ–∂–µ—Ç —É–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∞ –ø—Ä–æ–±–ª–µ–º—É —Å —Å–æ–∑–¥–∞–Ω–∏–µ–º –∫–æ–Ω–∫—É—Ä—Å–∞");
            }
        } catch (error) {
            console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ lastId: ${error}`);
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º contestId –≤ 1 –∫–∞–∫ –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
            contestId = BigInt(1);
            console.log(`–ò—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–ø–∞—Å–Ω–æ–π contestId: ${contestId}`);
        }

        try {
            // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–Ω–∫—É—Ä—Å–µ —á–µ—Ä–µ–∑ getContestInfo
            const contestInfo = await contestFactory.getContestInfo(Number(contestId));
            if (contestInfo && contestInfo.escrowAddress) {
                escrowAddress = contestInfo.escrowAddress;
            }
        } catch (error) {
            console.log(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ getContestInfo: ${error}`);
            try {
                // –ï—Å–ª–∏ getContestInfo –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø–æ–ª—É—á–∞–µ–º –∞–¥—Ä–µ—Å —ç—Å–∫—Ä–æ—É –Ω–∞–ø—Ä—è–º—É—é –∏–∑ –º–∞—Å—Å–∏–≤–∞
                escrowAddress = await contestFactory.escrows(Number(contestId) - 1);
            } catch (nestedError) {
                console.log(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ—Å—Ç—É–ø–µ –∫ escrows: ${nestedError}`);
            }
        }

        if (!escrowAddress || escrowAddress === ethers.ZeroAddress) {
            throw new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∞–¥—Ä–µ—Å —ç—Å–∫—Ä–æ—É –¥–ª—è contestId ${contestId}`);
        }
    }

    // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ escrowAddress - —ç—Ç–æ —Å—Ç—Ä–æ–∫–∞ –∏ –∏–º–µ–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
    let escrowAddressStr = '';
    try {
        escrowAddressStr = escrowAddress.toString();
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∞–¥—Ä–µ—Å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å 0x –∏ –∏–º–µ–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –¥–ª–∏–Ω—É
        if (!escrowAddressStr.startsWith('0x')) {
            escrowAddressStr = '0x' + escrowAddressStr;
        }

        // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –¥–ª–∏–Ω–∞ –∞–¥—Ä–µ—Å–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è (0x + 40 —Å–∏–º–≤–æ–ª–æ–≤)
        if (escrowAddressStr.length !== 42) {
            console.warn(`–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: –í–æ–∑–º–æ–∂–Ω–æ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∞–¥—Ä–µ—Å–∞: ${escrowAddressStr} (–¥–ª–∏–Ω–∞ ${escrowAddressStr.length})`);
        }

        console.log(`–ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ ContestEscrow –ø–æ –∞–¥—Ä–µ—Å—É: ${escrowAddressStr}`);
    } catch (error) {
        console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∞–¥—Ä–µ—Å–∞ —ç—Å–∫—Ä–æ—É: ${error}`);
        throw new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∞–¥—Ä–µ—Å —ç—Å–∫—Ä–æ—É: ${error}`);
    }

    let escrow: ContestEscrow;
    try {
        escrow = await ethers.getContractAt("ContestEscrow", escrowAddressStr) as unknown as ContestEscrow;
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω, –ø—ã—Ç–∞—è—Å—å –≤—ã–∑–≤–∞—Ç—å –∫–∞–∫–æ–π-—Ç–æ –º–µ—Ç–æ–¥
        await escrow.getAddress();
        console.log(`–ö–æ–Ω—Ç—Ä–∞–∫—Ç —ç—Å–∫—Ä–æ—É —É—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω –∏ –ø—Ä–æ–≤–µ—Ä–µ–Ω`);
    } catch (error) {
        console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ —ç—Å–∫—Ä–æ—É: ${error}`);
        throw new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–ª–∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ–Ω—Ç—Ä–∞–∫—Ç —ç—Å–∫—Ä–æ—É –ø–æ –∞–¥—Ä–µ—Å—É ${escrowAddressStr}: ${error}`);
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ contestId –ø–µ—Ä–µ–¥ –≤–æ–∑–≤—Ä–∞—Ç–æ–º
    // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å contestId –∏–∑ —Å–æ–±—ã—Ç–∏–π
    if (contestId === null) {
        console.warn("–í–Ω–∏–º–∞–Ω–∏–µ: contestId –Ω–µ –ø–æ–ª—É—á–µ–Ω –∏–∑ –ª–æ–≥–æ–≤, –ø—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ lastId");

        // –ï—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è lastId, –ø—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—Ç—É–¥–∞
        if (hasLastIdFunction) {
            try {
                const newLastId = await contestFactory.lastId();
                console.log(`–¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ lastId –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω–∫—É—Ä—Å–∞: ${newLastId}`);

                if (newLastId > initialLastId) {
                    // –ï—Å–ª–∏ lastId —É–≤–µ–ª–∏—á–∏–ª—Å—è, —Ç–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∫–æ–Ω–∫—É—Ä—Å–∞ —Ä–∞–≤–µ–Ω
                    // –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É –∑–Ω–∞—á–µ–Ω–∏—é lastId (newLastId - 1)
                    contestId = newLastId - BigInt(1);
                    console.log(`–ò—Å–ø–æ–ª—å–∑—É–µ–º lastId-1 –∫–∞–∫ contestId: ${contestId}`);
                } else {
                    // –ï—Å–ª–∏ lastId –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è, –∏—Å–ø–æ–ª—å–∑—É–µ–º initialLastId –∫–∞–∫
                    // –Ω–∞–∏–±–æ–ª–µ–µ –≤–µ—Ä–æ—è—Ç–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä
                    contestId = initialLastId;
                    console.log(`–ò—Å–ø–æ–ª—å–∑—É–µ–º initialLastId –∫–∞–∫ contestId: ${contestId}`);
                }
            } catch (error) {
                console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ lastId –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è: ${error}`);
                contestId = BigInt(1);
            }
        } else {
            // –ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è lastId –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            contestId = BigInt(1);
        }
    } else {
        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º contestId –≤ bigint –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π (–µ—Å–ª–∏ –≤–¥—Ä—É–≥ —ç—Ç–æ —Å—Ç—Ä–æ–∫–∞ –∏–ª–∏ —á–∏—Å–ª–æ)
        try {
            contestId = BigInt(contestId.toString());
        } catch (error) {
            console.warn(`–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å contestId –≤ bigint: ${error}`);
        }
    }

    // –õ–æ–≥–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    console.log(`–§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: contestId=${contestId}, escrowAddress=${escrowAddress}`);

    return {
        contestId,
        escrow,
        escrowAddress,
        transaction: createTx,
        receipt
    };
}

export async function createContest(
    contestFactory: ContestFactory,
    feeManager: NetworkFeeManager,
    creator: any,
    options: CreateContestOptions = {}
): Promise<{
    contestId: bigint;
    escrow: ContestEscrow;
}> {
    const result = await createTestContest(contestFactory, feeManager, creator, options);
    return {
        contestId: result.contestId,
        escrow: result.escrow
    };
}

/**
 * –ó–∞–≤–µ—Ä—à–∞–µ—Ç –∫–æ–Ω–∫—É—Ä—Å, —É–≤–µ–ª–∏—á–∏–≤–∞—è –≤—Ä–µ–º—è –±–ª–æ–∫—á–µ–π–Ω–∞ –ø–æ—Å–ª–µ endTime
 * @param escrow –ö–æ–Ω—Ç—Ä–∞–∫—Ç —ç—Å–∫—Ä–æ—É
 * @returns –¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –ø–æ—Å–ª–µ —É–≤–µ–ª–∏—á–µ–Ω–∏—è
 */
export async function simulateContestEnd(escrow: ContestEscrow): Promise<number> {
    const endTime = await escrow.endTime();
    const currentTime = await time.latest();

    if (currentTime < endTime) {
        await time.increaseTo(Number(endTime) + 1);
    }

    return await time.latest();
}

/**
 * –°–æ–∑–¥–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è –∫–æ–Ω–∫—É—Ä—Å–∞
 * @param currentTime –¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è
 * @param durationHours –ü—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫–æ–Ω–∫—É—Ä—Å–∞ –≤ —á–∞—Å–∞—Ö
 * @param delayHours –ó–∞–¥–µ—Ä–∂–∫–∞ –Ω–∞—á–∞–ª–∞ –∫–æ–Ω–∫—É—Ä—Å–∞ –≤ —á–∞—Å–∞—Ö
 * @returns –û–±—ä–µ–∫—Ç —Å –≤—Ä–µ–º–µ–Ω–µ–º –Ω–∞—á–∞–ª–∞ –∏ –æ–∫–æ–Ω—á–∞–Ω–∏—è –∫–æ–Ω–∫—É—Ä—Å–∞
 */
export function createContestTimeParams(currentTime: number, durationHours: number = 24, delayHours: number = 1) {
  const startTime = BigInt(currentTime + delayHours * 3600);
  const endTime = BigInt(currentTime + (delayHours + durationHours) * 3600);
  return { startTime, endTime };
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –≤—ã–ø–ª–∞—Ç—É –ø—Ä–∏–∑–æ–≤ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è–º
 * @param escrow –ö–æ–Ω—Ç—Ä–∞–∫—Ç —ç—Å–∫—Ä–æ—É
 * @param winner –ê–¥—Ä–µ—Å –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
 * @param _expectedPrize –û–∂–∏–¥–∞–µ–º–∞—è —Å—É–º–º–∞ –ø—Ä–∏–∑–∞
 * @returns –ü–æ–ª—É—á–µ–Ω–Ω–∞—è —Å—É–º–º–∞ –ø—Ä–∏–∑–∞
 */
export async function verifyPrizeClaim(escrow: ContestEscrow, winner: any, _expectedPrize: bigint): Promise<bigint> {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª—å –µ—â–µ –Ω–µ –ø–æ–ª—É—á–∏–ª –ø—Ä–∏–∑
  const hasClaimedBefore = await escrow.hasClaimed(winner.address);
  if (hasClaimedBefore) {
    throw new Error(`–ü–æ–±–µ–¥–∏—Ç–µ–ª—å ${winner.address} —É–∂–µ –ø–æ–ª—É—á–∏–ª –ø—Ä–∏–∑`);
  }

  // –ë–∞–ª–∞–Ω—Å –ø–æ–±–µ–¥–∏—Ç–µ–ª—è –¥–æ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–∏–∑–∞
  const winnerBalanceBefore = await ethers.provider.getBalance(winner.address);

  // –ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–∏–∑–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–º
  const claimTx = await escrow.connect(winner).claimPrize();
  const receipt = await claimTx.wait();

  // –£—á–∏—Ç—ã–≤–∞–µ–º –≥–∞–∑, –ø–æ—Ç—Ä–∞—á–µ–Ω–Ω—ã–π –Ω–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
  const gasUsed = receipt ? receipt.gasUsed * receipt.gasPrice : BigInt(0);

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª—å –ø–æ–ª—É—á–∏–ª –ø—Ä–∏–∑
  const winnerBalanceAfter = await ethers.provider.getBalance(winner.address);
  const actualReceived = winnerBalanceAfter + gasUsed - winnerBalanceBefore;

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å—Ç–∞—Ç—É—Å –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–∏–∑–∞ –æ–±–Ω–æ–≤–∏–ª—Å—è
  const hasClaimedAfter = await escrow.hasClaimed(winner.address);
  if (!hasClaimedAfter) {
    throw new Error(`–°—Ç–∞—Ç—É—Å –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–∏–∑–∞ –Ω–µ –æ–±–Ω–æ–≤–∏–ª—Å—è –¥–ª—è ${winner.address}`);
  }

  return actualReceived;
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–µ –∞–¥—Ä–µ—Å–∞ –¥–ª—è —á–ª–µ–Ω–æ–≤ –∂—é—Ä–∏
 * @param count –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–¥—Ä–µ—Å–æ–≤ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
 * @returns –ú–∞—Å—Å–∏–≤ –∞–¥—Ä–µ—Å–æ–≤
 */
export function generateTestJury(count: number): string[] {
    const jury: string[] = [];
    for (let i = 0; i < count; i++) {
        jury.push(ethers.Wallet.createRandom().address);
    }
    return jury;
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–µ –∞–¥—Ä–µ—Å–∞ –¥–ª—è –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π
 * @param count –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–¥—Ä–µ—Å–æ–≤ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
 * @returns –ú–∞—Å—Å–∏–≤ –∞–¥—Ä–µ—Å–æ–≤
 */
export function generateTestWinners(count: number): string[] {
    const winners: string[] = [];
    for (let i = 0; i < count; i++) {
        winners.push(ethers.Wallet.createRandom().address);
    }
    return winners;
}

export { simulateContestEnd as endContest };
export { generateTestJury as generateJury };
export { generateTestWinners as generateWinners };

